# RTL TO GDS 

<details>

<summary>Tools Installation</summary>

### Install Yosys

#### Yosys is a Verilog HDL synthesis tool. This means that it takes a behavioural design description as input and generates an RTL, logical gate or physical gate level description of the design as output. Yosys’ main strengths are behavioural and RTL synthesis.

$ sudo apt-get update

$ git clone https://github.com/YosysHQ/yosys.git

$ cd yosys

$ sudo apt install make (If make is not installed ,install it)

$ sudo apt-get install build-essential clang bison flex
libreadline-dev gawk tcl-dev libffi-dev git
graphviz xdot pkg-config python3 libboost-system-dev
libboost-python-dev libboost-filesystem-dev zlib1g-dev

$ make config-gcc

$ make

$ sudo make install

<img width="429" alt="image" src="https://github.com/user-attachments/assets/56ee140f-3948-4352-a7ec-4787843e3890">


### install iverilog

#### iverilog: Icarus Verilog, commonly known as Iverilog, is an open-source tool used for the simulation and synthesis of digital circuits described in Verilog hardware description language (HDL).Primarily, Iverilog is used to simulate Verilog designs, allowing designers to verify the functionality of their digital circuits before physical implementation.

$ sudo apt-get install iverilog

<img width="397" alt="image" src="https://github.com/user-attachments/assets/4c3d4240-1a52-474b-8b3b-1af524da6aa6">

### install gtkwave

sudo apt-get update

sudo apt install gtkwave

<img width="574" alt="image" src="https://github.com/user-attachments/assets/7edf13db-e248-4153-af7e-5e47627cb532">

</details>

<details>

<summary>Introduction to Verilog RTL Design and Synthesis</summary>

In RTL design, the adherence to specifications is verified through simulation using a tool called a simulator. For this course, the simulator used is Icarus Verilog (Iverilog). The design refers to the actual Verilog code or set of codes that implement the intended functionality to meet the required specifications.

A testbench is used to apply stimulus, or test vectors, to the design to check its functionality. The simulator operates by monitoring changes in input signals; when an input changes, the corresponding output is evaluated. If there are no changes in the input, the output remains unchanged, as the simulator continuously checks for variations in input values to determine the resultant outputs.

### Block diagram of Test Bench

<img width="571" alt="image" src="https://github.com/user-attachments/assets/1e1b9aea-2c98-47b7-9dea-2d35718766ce">

### iverilog based simulation flow

![image](https://github.com/user-attachments/assets/31d49bf1-6689-48fa-8f9f-e5a159bdaaf8)

### LAB1- good_mux

Run the simulation on good_mux with the test bench tb_good_mux in iverilog.

<img width="364" alt="image" src="https://github.com/user-attachments/assets/2deb5f15-cc0e-4351-81d0-c53efeff4c18">

### testbench for good_mux

<img width="613" alt="image" src="https://github.com/user-attachments/assets/1cbc1109-4900-4262-8440-d453bb17ef69">

Icarus Verilog (Iverilog) takes design files and testbench files as inputs. The output of Iverilog is a .vcd (Value Change Dump) file, an ASCII-based format generated by EDA logic simulation tools. This file records changes in signal values throughout the simulation. The .vcd file can then be used as an input for the GTKWave tool, which visualizes the waveforms of the design's signals. By viewing these waveforms, one can verify the correctness of signal transitions according to the stimulus provided by the testbench.

#### Commands used

The output will be a.out file for the simulation 

<img width="608" alt="image" src="https://github.com/user-attachments/assets/c958b4f3-442e-4fc6-83a9-cc4454bd914c">

To view the simulation results, use a waveform viewer like GTKWave. Open the GTKWave and load the generated VCD file:

### Waveforms in gtkwave

<img width="604" alt="image" src="https://github.com/user-attachments/assets/efac9690-d4ea-48fb-80e3-b7e30b7cc0e3">

## Introduction to Yosys RTL Synthesizer

Yosys is an open-source framework for Verilog RTL synthesis. It is used primarily for converting high-level Verilog descriptions of digital circuits into gate-level netlists that can be implemented on FPGAs or used for ASIC design. Yosys is highly versatile and supports various front-end and back-end tools, making it a valuable tool for digital design and synthesis.

Inputs for Yosys tool: Design (.v), Liberty (.lib)
Output: Netlist file (.net.v)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/574fea39-d6d6-46f2-9495-1867525ad5ed">

Verifying the design:

Use the Test bench using in RTL phase.Using the same stimulus used for RTL, the output expected should be the same as the one obtained in RTL phase.

<img width="598" alt="image" src="https://github.com/user-attachments/assets/db8d6336-823e-4225-a51f-3f95918fbb4b">

### Synthesis

The process of transforming the RTL description into a lower-level representation consisting of gates and their interconnections. This process is typically performed using a synthesis tool, which maps the RTL code to a specific technology library containing various gate-level components like AND, OR, NOT gates, flip-flops, and more.

<img width="184" alt="image" src="https://github.com/user-attachments/assets/d255aaa7-104f-42f2-92d1-dc63f8ca1012">

### What is .lib?

A .lib file, or a standard cell library file, is a collection of different standard cells that vary in functionality, input configurations, and other characteristics. These cells can implement various logic functions and are available in multiple performance models, such as slow, medium, and fast. Each model caters to different design requirements, providing options for trade-offs in speed, power, and area. This library enables designers to choose the appropriate cells to meet specific design criteria and constraints.

Block diagram shows how the Synthesizer works

<img width="440" alt="image" src="https://github.com/user-attachments/assets/a0eda8cc-2df0-4c11-a8e8-26d19454299c">

### Synthesis of good_mux.v

#### 1.Read the liberty source file

yosys> read_liberty -lib ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#### 2. Read the Verilog source file

yosys> read_verilog good_mux.v

#### 3. Do Synthesis

yosys> synth -top good_mux

<img width="608" alt="image" src="https://github.com/user-attachments/assets/f1b30a9a-6b51-41e1-8675-c01fa1f12f26">

<img width="611" alt="image" src="https://github.com/user-attachments/assets/9b5b32b9-ad4c-43d5-a88f-abf5c1da890a">

#### 4. Technology Mapping to the Design using the abc tool which is integrated with Yosys:

 yosys> abc -liberty ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

<img width="605" alt="image" src="https://github.com/user-attachments/assets/d414464c-58bf-44cc-82ba-faa1c8590762">

<img width="605" alt="image" src="https://github.com/user-attachments/assets/e7f45182-7529-4667-a9c6-9078a8ca64fe">

#### 5. Generated Gate level Netlist

 yosys> show

<img width="604" alt="image" src="https://github.com/user-attachments/assets/66b32437-262d-46a3-a918-71128b05d529">

#### 6. Write the synthesized netlist to a Verilog file:

write_verilog good_mux_netlist.v

<img width="257" alt="image" src="https://github.com/user-attachments/assets/9bdc2f46-4455-404c-bacb-0ac57387c6fd">

yosys> write_verilog -noattr good_mux.netlist.v

<img width="235" alt="image" src="https://github.com/user-attachments/assets/5a7ef4fd-5ca1-452f-b32e-8a7e875ac584">

</details>

<details>

<summary>Timing libs, hierarchical vs flat synthesis and efficient flop coding styles</summary>


 A .lib file, also referred to as a Liberty file, is a standardized format in the electronic design automation (EDA) industry. Library cell description contains a lot of information like timing information, power estimation, other several attributes like area, functionality, operating condition etc. Speaking more technically, liberty format is a format to represent timing and power properties of black boxes (which we cant descend into). Liberty is an ASCII format, usually represented in a text file with extension “.lib“.

### Key Elements of a .lib File:
**Timing Information:** Details about the delay and timing constraints of the cells.  
**Power Information:** Data on power consumption, including dynamic and leakage power.  
**Area Information:** The physical area occupied by the cells.  
**Operating Conditions:** Environmental parameters like temperature and voltage for which the cells are characterized.  
**Pin Descriptions:** Information about the input and output pins of the cells, including their functions and electrical properties.

In our lab, we utilize the **sky130_fd_sc_hd_tt_025C_1v80.lib file.** Here’s an explanation of the filename components:

**sky130:** Refers to the 130nm technology node provided by SkyWater Technology Foundry.  
**fd:** Stands for fully-depleted, indicating the type of process technology.  
**sc:** Stands for standard cell.  
**hd:** Stands for high-density standard cell library.  
**tt:** Typical process corner (typical-typical).  
**025C:** The temperature condition at which the library data is characterized (25°C).  
**1v80:** The operating voltage condition (1.8V).

Snippet of .lib file

<img width="556" alt="image" src="https://github.com/user-attachments/assets/944ca820-6afa-4a54-91f0-8fd779270789">

Snippet showing leakage power in .lib file

<img width="527" alt="image" src="https://github.com/user-attachments/assets/924bd95c-604d-487a-a305-5c35b2c4b726">

Timing(Cell rise/fall delay etc.) in lookup table format:

<img width="563" alt="image" src="https://github.com/user-attachments/assets/9c82cbbb-60f8-4308-9540-5becc2bbea77">

Comparison of the area occupied by 2-input AND gates with varying drive strengths or widths shows that gates with higher drive strengths or greater widths occupy more area and will have less delay.

<img width="584" alt="image" src="https://github.com/user-attachments/assets/12e1b1e7-8c14-425e-a9be-a4505d504945">

### Hierarchial vs Flat Synthesis

#### Hierarchial Synthesis

In VLSI (Very Large Scale Integration) design, hierarchical synthesis and flat synthesis are two approaches to synthesizing a digital circuit from a high-level description to a gate-level representation. They differ in how they manage and optimize the design hierarchy during the synthesis process.

**Hierarchical Synthesis**
**Definition:** Hierarchical synthesis, also known as module-based or top-down synthesis, involves preserving the design hierarchy throughout the synthesis process. The design is divided into modules or blocks, and each module is synthesized separately, maintaining its boundaries and interfaces.

Invoking yosys to synthesize example multiple_modules.v

<img width="395" alt="image" src="https://github.com/user-attachments/assets/8a44fa1e-18a9-48bb-bda3-b5f059d28882">

<img width="380" alt="image" src="https://github.com/user-attachments/assets/f6e50452-0abb-45c0-854c-9ba1408140ab">

**1. Read the Liberty source file:**

yosys> read_liberty -lib ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

__2.Read the Verilog source file:__

yosys> read_verilog multiple_modules.v

__3.Perform synthesis:__

yosys> synth -top multiple_modules

<img width="605" alt="image" src="https://github.com/user-attachments/assets/1e6516f4-ebae-4af7-b59b-67d2d0712052">

Here, Sub_module1 has one and gate, sub_module2 has one OR gate 

<img width="598" alt="image" src="https://github.com/user-attachments/assets/e7ce7c06-4561-49d3-b396-862a1b518790">

Top mdoule multiple_module has sub_module1 and sub_module2 of one instance each and totally it contains 2 cells of both AND and OR gate

<img width="602" alt="image" src="https://github.com/user-attachments/assets/20e8c937-d28d-48ce-b583-9d7cc39cddd2">

**4.Technology Mapping to the Design using abc tool which is integrated with Yosys:**

yosys> abc -liberty ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

<img width="611" alt="image" src="https://github.com/user-attachments/assets/e0aea456-40a4-4a7b-b4a1-2ec3fd5fe849">

**5.View the generated gate level netlist:**

yosys> show multiple_modules

<img width="602" alt="image" src="https://github.com/user-attachments/assets/67cd5911-cc1a-4b8a-8e01-f815fa48745d">

Interestingly, the design is not displaying the AND and OR gates explicitly. Instead, it shows them as u1 and u2, which are instances of sub_module1 and sub_module2, respectively. Ideally, one would expect to see the AND and OR gates directly. This approach is known as hierarchical design, where the hierarchies are preserved, and the design maintains its modular structure.

**Flat synthesis:** Flat synthesis involves synthesizing the entire design as a single, monolithic entity without hierarchical organization.

**1.To flatten the design:**

yosys> flatten

<img width="311" alt="image" src="https://github.com/user-attachments/assets/328012d6-6823-42b2-abda-bbbb045abc43">

**2.To write a netlist to .v file:**

yosys> write_verilog -noattr multiple_modules_flat.v

<img width="335" alt="image" src="https://github.com/user-attachments/assets/17110aff-0dbf-4af3-9685-b76ba4b03bdc">

**3.To view the netlist (.v):**

yosys> !givim multiple_modules_flat.v

<img width="610" alt="image" src="https://github.com/user-attachments/assets/f269f628-22e3-49fc-9c81-73618e5b3f0b">

<img width="641" alt="image" src="https://github.com/user-attachments/assets/af3db9bb-dc9c-49ab-9636-8757b60f9084">

In the first case, the hierarchies of submodule1 and submodule2 are preserved. In the second case, we see a single netlist where the hierarchies are flattened out, and we directly see the instantiation of the AND gate and OR gate under multiple modules.

**4.To view the flattened gate level netlist:**

yosys> show

<img width="605" alt="image" src="https://github.com/user-attachments/assets/85119854-0c3f-4c1c-9123-17f55ae34b42">

So, when we flatten the design, we can see the structure completely.

### Sub module level synthesis###

Given multitiple modules, lets say we want to synthesize each sub module

**1.Read the Liberty source file:**

yosys> read_liberty -lib ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

<img width="418" alt="image" src="https://github.com/user-attachments/assets/775dbb23-39d3-4ca3-bb98-0c86261e66cb">

**2.Read the Verilog source file:**

yosys> read_verilog multiple_modules.v

<img width="404" alt="image" src="https://github.com/user-attachments/assets/425116f0-c082-44e9-826e-8805e0c065fe">

**3.Perform synthesis:**

yosys> synth -top sub_module1

<img width="604" alt="image" src="https://github.com/user-attachments/assets/cb367283-2004-43ae-8734-4c2949a6c56c">

**4.Technology Mapping to the Design using abc tool which is integrated with Yosys:**

yosys> abc -liberty ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

<img width="605" alt="image" src="https://github.com/user-attachments/assets/0f843ff7-ced0-4fd9-85a3-e348e95d5929">

**5.To view the generated gate level netlist:**

yosys> show

<img width="241" alt="image" src="https://github.com/user-attachments/assets/e00d191e-5e48-48f6-a596-ed78ccefbb70">

Sub-module level synthesis is preferred:

1.When we have multiple instances of the same module  2. When the design is massive.

### Different Methods for Flip-Flop Coding and Performance Enhancement

**Why are flops necessary, and how do they mitigate glitches in the circuit?**

Glitches in digital circuits often arise due to signal delays, noise, or timing mismatches. Flops are essential in preventing these glitches by:

Synchronization: Flops are edge-triggered, responding only to specific transitions like clock edges, ensuring that output changes occur at precise moments, reducing the chance of glitches caused by transient signals.

Timing Control: Flops are driven by a clock signal, ensuring that all circuit operations are synchronized. This coordination prevents timing mismatches, which could otherwise lead to glitches when data arrives at different times.

So,Flip-Flops can be used to restrict glitch propagation as:

Flip-flops are edge triggered circuits,so the output changes on edge of the clock signal,so even if input of flops are glitchy,output remains stable.
Combinational circuits driven by the flops,will receive stable inputs,hence their glitches will eventually settle down.

<img width="740" alt="image" src="https://github.com/user-attachments/assets/ef17901d-53bd-48d0-b0f1-a877524954c1">

The value of the flop must be in a known state all the time,for this signals like reset or set are used to control the initial state . set and reset can be synchronous or asynchronous.

#### Flops and Flop coding styles

Combinational circuits can produce glitches while settling to a final value when cascaded. Flip-flops are essential to store these final values, allowing changes only when an external signal confirms that the combinational logic has stabilized. The output Q of the flip-flop is protected from changes at the input D until the appropriate timing signal is applied. Set/reset signals are used to initialize the flip-flop, ensuring that the initial output of Q is a known, stable value.

**Simulation of Asynchronous Reset D-Flip Flop using iverilog followed by GTKWave**

<img width="401" alt="image" src="https://github.com/user-attachments/assets/a17e38da-f2e9-4665-b784-80e0db581b41">

<img width="604" alt="image" src="https://github.com/user-attachments/assets/7cb1918a-44ca-479b-85b1-4c0184a0fbb4">

Commands used:

1.iverilog dff_asyncres.v tb_dff_asyncres.v  2../a.out  3.gtkwave tb_dff_asyncres.vcd

<img width="639" alt="image" src="https://github.com/user-attachments/assets/0c5e04ae-0066-4cff-87ba-4562f5294f87">

<img width="604" alt="image" src="https://github.com/user-attachments/assets/51829bfc-8061-45c6-bc0f-8f76e973d10e">

In the scenario described, when the reset signal goes low before the clock arrives and d is high, the output Q of the flip-flop does not immediately go to 1. Instead, it waits for the clock edge. This means that d is aligned with the clock, and the flip-flop only senses the value of d at the clock edge. The output q is therefore synchronized to the clock; d may change at any time, but q will only update when the clock edge occurs, ensuring that changes in q happen in sync with the clock when driven by d.

**Simulation of Synchronous Reset D-Flip Flop using iverilog followed by GTKWave**

<img width="640" alt="image" src="https://github.com/user-attachments/assets/ab809fab-1c04-483b-b7ff-8438f6c13cc3">

**Synthesis of Asynchronous Reset D-Flip Flop using yosys:**

Here, we have to map the Flip-Flops to the dfflib which is present in sky130_fd_sc_hd_tt_025C_1v80.lib

Here's the command for mapping the flipflops to the dfflib:

yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd_tt_025C_1v80.lib

![image](https://github.com/user-attachments/assets/e2617527-845e-444c-ba62-1e7b3d8d2813)

**Synthesis of Asynchronous set D-Flip Flop using yosys:**

![image](https://github.com/user-attachments/assets/22ca9d8b-35e0-40f3-8f1e-4aeb86b5d466)

**Synthesis of Synchronous Reset D-Flip Flop using yosys:**

![image](https://github.com/user-attachments/assets/02bc9128-4d3d-4863-b17e-4aa21620ec80)

</details>

<details>
    <summary>Combinational and Sequential Optimization</summary>

  <ul>
        <li>
            <details>
                <summary>Combinational Logic Optimization</summary>
                <ul>
                    <li>
                        <details>
                           <summary><strong>PART 1: For opt_check Modules</strong></summary>
                            <ol>
                                <li>
                                    <strong>Step 1: Read Library</strong>
                                    <p>In Yosys, execute the command to read the library:</p>
                                    <img width="728" alt="Read Library" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/bf2a8b14-da19-41ff-96ac-ee1fc0572722">
                                </li>
                                <li>
                                    <strong>Step 2: Read Verilog File</strong>
                                    <p>Load the Verilog file for the 'opt_check' module:</p>
                                    <img width="652" alt="Verilog File" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/1c68e3e0-f349-4a91-9aa0-df769f531e71">
                                </li>
                                <li>
                                    <strong>Step 3: Define Module for Synthesis</strong>
                                    <p>Define the module to be synthesized and view the number of cells in the module:</p>
                                    <img width="286" alt="Define Module" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/7e9cb74a-e0d5-4779-b786-eb7d62618c60">
                                    <img width="420" alt="Cell Count" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/ea4b5d4a-122a-4881-903f-66d5a37996c0">
                                </li>
                                <li>
                                    <strong>Step 4: Execute opt_clean</strong>
                                    <p>Run opt_clean to remove unused cells and wires:</p>
                                    <img width="623" alt="opt_clean Execution" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/b9d682ef-5229-4092-9dff-ac44c408aff0">
                                </li>
                                <li>
                                    <strong>Step 5: Generate Netlist</strong>
                                    <p>Generate the netlist and observe the reduction in the number of cells:</p>
                                    <img width="611" alt="Netlist Generation" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4d887668-b080-4942-a05d-5350f1ac6e51">
                                    <img width="598" alt="Cell Reduction" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/78dbf1ca-d2c6-458c-9b3e-8ef595bd0c82">
                                </li>
                                <li>
                                    <strong>Step 6: View Netlist Design</strong>
                                    <p>Execute the show command to view the netlist design:</p>
                                    <img width="611" alt="View Netlist" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/0992c28f-063b-4a43-90b0-b2abdfad762b">
                                </li>
                                <li>
                                    <strong>Steps 7-12: Repeat for Additional Modules</strong>
                                    <p>Repeat the above steps for additional modules (opt_check2, opt_check3, opt_check4), observing the changes and improvements each time:</p>
                                    <img width="418" alt="Further Steps" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/16b97a65-65b6-4b51-ac38-3218c9d2865d">
                                    <img width="556" alt="ABC Command" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/17c9dd9f-fd22-4312-bb51-0be49eadb040">
                                    <img width="497" alt="Further ABC Command" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/3607a834-f446-462b-ab11-25856870721a">
                                </li>
                            </ol>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary><strong>PART 2: multiple_modules Optimization</strong></summary>
                            <ol>
                                <li>
                                    <strong>Step 1: Read Verilog File</strong>
                                    <p>Load the Verilog file for 'multiple_modules_opt.v'.</p>
                                    <img width="744" alt="Read Verilog File" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4ef7a599-3701-4953-8c1a-450a923a9876">
                                </li>
                                <li>
                                    <strong>Step 2: Define the Module for Synthesis</strong>
                                    <p>Specify which module to synthesize.</p>
                                    <img width="398" alt="Define Module" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/73c1c313-ae77-45ad-9814-436b4d1cdebf">
                                </li>
                                <li>
                                    <strong>Step 3: Flatten the Design</strong>
                                    <p>Apply design flattening techniques to simplify the hierarchy.</p>
                                    <img width="475" alt="Flatten Design" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/7dd4686a-7897-4ba8-8a65-52111a04903d">
                                </li>
                                <li>
                                    <strong>Step 4: Execute opt_clean</strong>
                                    <p>Remove unused cells and wires to optimize the design.</p>
                                    <img width="635" alt="Execute opt_clean" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4bfecaba-c49b-4ca9-958e-f1e7486aaa62">
                                </li>
                                <li>
                                    <strong>Step 5: Generate the Netlist</strong>
                                    <p>Generate the netlist and note the reduction in the number of cells.</p>
                                    <img width="617" alt="Generate Netlist" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/c7b85d9d-f18d-4992-bf0b-151f22301e3d">
                                    <img width="571" alt="Cell Reduction" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/cf863f0b-27aa-4781-8b36-0e6bd0f6275a">
                                </li>
                                <li>
                                    <strong>Step 6: View Netlist Design</strong>
                                    <p>Display the synthesized netlist design to verify correctness and optimization.</p>
                                    <img width="595" alt="View Netlist Design" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/83c65d81-da59-49a9-8735-3938a35d7c18">
                                </li>
                                <li>
                                    <strong>Step 7: Repeat Optimization for Additional Module</strong>
                                    <p>Repeat the optimization steps for 'multiple_modules_opt2.v' and observe changes.</p>
                                </li>
                                <li>
                                    <strong>Step 8: View Netlist Design for Additional Module</strong>
                                    <p>Review the final netlist design for 'multiple_modules_opt2.v'.</p>
                                    <img width="353" alt="Final Netlist Design" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/18374a6c-27ec-4bb3-9094-b057cbc6a9e2">
                                </li>
                            </ol>
                        </details>
                    </li>
                </ul>
            </details>
        </li>
        <li>
            <details>
                <summary>Sequential Logic Optimization</summary>
                <ul>
                    <li>
                        <details>
                            <summary><strong>PART 1: Dff_const Synthesis</strong></summary>
                            <ol>
                                <li>
                                    <strong>Step 1: Read the Library</strong>
                                    <p>Load the required library in Yosys.</p>
                                    <img width="735" alt="Read Library" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/c4b43fb9-4a90-4695-842f-d68680ce4f0b">
                                </li>
                                <li>
                                    <strong>Step 2: Read the Verilog File</strong>
                                    <p>Load the Verilog file for 'dff_const1.v'.</p>
                                    <img width="669" alt="Read Verilog File" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/e85367f2-5aa3-4692-9684-a5726016a08e">
                                </li>          
                                <li>
                                    <strong>Step 3: Define the Module for Synthesis</strong>
                                    <p>Specify the module to be synthesized and view the design hierarchy.</p>
                                    <img width="306" alt="Define Module" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/c5e25901-ce0f-4520-9e21-ac1d5bc2666c">
                                    <img width="422" alt="Design Hierarchy" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/80bc0503-0ade-47e4-bb10-a6773c53051f">
                                </li>
                                <li>
                                    <strong>Step 4: Run dfflibmap</strong>
                                    <p>Map the D flip-flop cells to sequential cells using dfflibmap.</p>
                                    <img width="870" alt="Run dfflibmap" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/76ce4935-130d-4692-a5b3-211c7211afdc">
                                </li>
                                <li>
                                    <strong>Step 5: Generate the Netlist</strong>
                                    <p>Create the netlist for the design.</p>
                                    <img width="611" alt="Generate Netlist" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4802d8a6-2763-4975-be62-805a4473ac2a">
                                </li>
                                <li>
                                    <strong>Step 6: View the Design</strong>
                                    <p>Execute the 'show' command to view the synthesized design.</p>
                                    <img width="594" alt="View Design" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/8dcc75b9-0bc2-43a3-89ae-9b0a1a8b6122">
                                </li>
                                <li>
                                    <strong>Steps 7-12: Repeat for Additional Files</strong>
                                    <p>Repeat the above steps for 'dff_const2.v', 'dff_const3.v', and 'dff_const4.v', viewing the design after each synthesis.</p>
                                    <img width="609" alt="View Design 2" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/481c7486-83c1-4fe3-8301-ba1f930bc791">
                                    <img width="1359" alt="View Design 3" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/5f8109ea-1f69-4d4f-bdb5-fb59e37cc882">
                                    <img width="616" alt="View Design 4" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/69a155b4-d899-4597-9631-59e497c7edb5">
                                </li>
                            </ol>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary><strong>PART 2: Sequential Optimizations for Unused Outputs</strong></summary>
                            <ol>
                                <li>
                                    <strong>Step 1: Read the Library</strong>
                                    <p>Load the required library in Yosys.</p>
                                    <img width="744" alt="Read Library" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/f2b3de6b-a2c1-498b-b957-aec0487c08be">
                                </li>
                                <li>
                                    <strong>Step 2: Read the Verilog File</strong>
                                    <p>Load the Verilog file for 'counter_opt.v'.</p>
                                    <img width="663" alt="Read Verilog File" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/c603c612-d903-4e05-ab1d-bde84a52fd3c">
                                </li>          
                                <li>
                                    <strong>Step 3: Define the Module for Synthesis</strong>
                                    <p>Specify the module to be synthesized and view the design hierarchy.</p>
                                    <img width="324" alt="Define Module" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/1a4979c3-0da7-4cf9-9bb2-a698f2b4c51d">
                                    <img width="407" alt="Design Hierarchy" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/ecd2ad69-1e69-44cf-8403-d8670bf7028e">
                                </li>
                                <li>
                                    <strong>Step 4: Run dfflibmap</strong>
                                    <p>Map the D flip-flop cells to sequential cells using dfflibmap.</p>
                                    <img width="873" alt="Run dfflibmap" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/65e34b53-4b7a-4d55-a43f-0cf59489a386">
                                </li>
                                <li>
                                    <strong>Step 5: Generate the Netlist</strong>
                                    <p>Create the netlist for the design.</p>
                                    <img width="621" alt="Generate Netlist" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/d4b49572-0224-4ca6-978d-71ace7464ce3">
                                </li>
                                <li>
                                    <strong>Step 6: View the Design</strong>
                                    <p>Execute the 'show' command to view the synthesized design.</p>
                                    <img width="1361" alt="View Design" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/26807584-5733-4728-bc9f-de30d5d18d4d">
                                </li>
                                <li>
                                    <strong>Steps 7-8: Repeat for Additional Files</strong>
                                    <p>Repeat the above steps for 'counter_opt2.v', viewing the design after synthesis.</p>
                                    <img width="425" alt="View Design 2" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/2fdaa020-ca5a-4bf7-9ca2-b4087914ac52">
                                    <img width="1370" alt="View Design 3" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/848db3bb-35bd-4fd2-8e92-122e76d86f70">
                                </li>
                            </ol>
                        </details>
                    </li>
                </ul>
            </details>
        </li>
    </ul>
</details>

<details>
    <summary> Gate Level Simulation, Synthesis Simulation Mismatch, and Blocking & Non-Blocking Statements </summary>
 Gate-level simulation is a critical process in digital design, verification, and validation, especially for complex digital systems in modern technology nodes. It involves modeling digital circuits at the gate level to understand their behavior accurately. Gate-level simulation occurs after synthesis, providing a detailed netlist representation of the circuit with functional and timing characteristics. This simulation method is essential for dynamic behavior verification, complex timing checks, power efficiency concerns, and design-for-test features integrated at the gate level,ensuring the accuracy of scan chain insertions in DFT. Gate-level simulation is crucial for gaining confidence in design and verification, offering a more comprehensive analysis than static methods. It plays a pivotal role in validating, verifying, and optimizing digital circuits, making it a cornerstone of digital design.

In Gate level Simulation(GLS): Testbench used for RTL verification is used for netlist simulation,as they are logically same.

Why GLS?

Verify the correctness of the design after synthesis
Ensure the timing of the design is met which is done with delay annotation (timing aware)
GLS Flow using iverilog: 

![image](https://github.com/user-attachments/assets/345c4b03-b35b-43f9-a5a0-0a6604281e3d)

Synthesis-Simulation mismatch occurs due to following reasons:

Missing sensitivity list

Blocking vs non-blocking assignments

Non-standard verilog coding

***1.Misiing Sensitivity list**

Missing Sensitivity List:

Simulator works when change in signals (activity) occurs,and output gets updated. If the sensitivity list of always block does not contain all input signals,it will cause mismatches between synthesis and simulation.

For ex: As seen in the screenshot below, in the left column,always block is evaluated only when sel is changing. So output y is not reflecting changes in input i1 and i0 when sel is not changing. Rather it acts like a latch. The code on the right side represents the correct design coding for mux. In this case always is evaluated for any signal changes.

![image](https://github.com/user-attachments/assets/64486d48-d514-4854-97b5-7f8ddf11b976)

As seen in the screenshot below,the code in left column is correct to achieve our aim of inferring two flip-flops but in code in right column,as q is getting directly assigned to d , hence only one flop is inferred. Hence,it is recommended to always use non-blocking statement in always block for sequential logic inference.

![image](https://github.com/user-attachments/assets/d6292caf-9296-4ff5-9c02-ccced848e2fc)

For ex: In left column code,y will get old value of q0 during evaluation/simulation,which is mimicking the behavour of a flop. To get latest value of q0,we can interchange the statements in always block,as seen in right column code. Synthesis will produce the same logic implementation for both the codes. This will lead to synthesis-simulation mismatch. 

![image](https://github.com/user-attachments/assets/b9d53842-26fa-435a-8450-ed8d85527674)
    <ul>
        <li>
            <details>
                <summary>Lab on GLS and Synth Simulation Mismatch</summary>
                <ul>
                    <li>
                        <details>
                            <summary>PART 1: For ternary_operator_mux</summary>
                            <p>Step 1</p>
                            <pre>
                            
<img width="603" alt="image" src="https://github.com/user-attachments/assets/03dc47ea-e7ca-4b7d-b5ce-c2c0eafc5188">
                            
Load ternary_operator_mux.v & its testbench to Iverilog.

<img width="608" alt="image" src="https://github.com/user-attachments/assets/9ce3e939-8e65-48b5-9cf3-93b95a72186f">
                           </pre>
                            <p>Step 2</p>
                            <pre>
Execute a.out file.

<img width="537" alt="image" src="https://github.com/user-attachments/assets/220edbf8-7cd0-4584-bfa8-65387cd96984">
                            </pre>
                            <p>Step 3</p>
                            <pre>
Load the .vcd file genrated into GTKWave.
                             
<img width="604" alt="image" src="https://github.com/user-attachments/assets/3cfb4fdd-043d-42b1-b6df-2c3c798b2077">

The ternary_operator_mux's behavior is analyzed on GTKWave   

<img width="604" alt="image" src="https://github.com/user-attachments/assets/3636f09d-7320-401b-aee5-4210b3acc97c">
                            </pre>
                            <p>Step 4</p>
                            <pre>
Invoke Yosys by using command yosys
                             
<img width="511" alt="image" src="https://github.com/user-attachments/assets/eff0bb7c-4c03-44d7-af46-177b869b8b28">
                            </pre>
                            <p>Step 5</p>
                            <pre>
Read the library using read_liberty
                             
<img width="374" alt="image" src="https://github.com/user-attachments/assets/cccf22e9-c129-4f24-8752-08b46920bc3d">
                            </pre>
                            <p>Step 6</p>
                            <pre>
Read the ternary_operator_mux.v using read_verilog
                             
<img width="392" alt="image" src="https://github.com/user-attachments/assets/0e0427cc-2a25-40b9-8506-5f4bcfa91b04">
                            </pre>
                            <p>Step 7</p>
                            <pre>
Define the module that needs to be synthesized
                             
<img width="389" alt="image" src="https://github.com/user-attachments/assets/325720ec-50c6-4da4-af6a-df052ac773e1">

<img width="321" alt="image" src="https://github.com/user-attachments/assets/df448d4f-7202-4d6e-92f0-2f2ab9d4dcfa">
                            </pre>
                            <p>Step 8</p>
                            <pre>
Generate the netlist using abc command
                             
<img width="602" alt="image" src="https://github.com/user-attachments/assets/a871caf2-6e48-4506-82cd-1566a047645c">
                            </pre>
                            <p>Step 9</p>
                            <pre>
Write the netlist to ternary_operator_mux_net.v
                             
<img width="326" alt="image" src="https://github.com/user-attachments/assets/9e7e9fb1-f7e6-4b40-ad44-c0c67bfdb19f">
                            </pre>
                            <p>Step 10</p>
                            <pre>
Execute show to view the design
                             
<img width="584" alt="image" src="https://github.com/user-attachments/assets/740447f6-c7ce-463d-bac2-df78608a862d">
                            </pre>
                            <p>Step 11</p>
                            <pre>
Exit yosys and load the ternary_operator_mux_net.v to iverilog.
                             
<img width="611" alt="image" src="https://github.com/user-attachments/assets/8fbb45c4-be16-49fb-af97-f25b36562628">
                            </pre>
                            <p>Step 12</p>
                            <pre>
Execute a.out file.
                             
<img width="591" alt="image" src="https://github.com/user-attachments/assets/a822fcf4-139e-43a4-b2fa-aa39cf076a52">
                            </pre>
                            <p>Step 13</p>
                            <pre>
Load the generated .vcd file into GTKWave
                             
<img width="1107" alt="Screenshot 2024-05-26 at 2 33 19 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4b04c1e3-5aff-4937-9670-706364e92fa3">
                            </pre>
                            <p>Step 14</p>
                            <pre>
Observe the GLS of ternary_operator_mux
                             
<img width="1357" alt="Screenshot 2024-05-26 at 2 33 52 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/746f372e-4dd9-4da4-a4ff-57836f00945e">
                            </pre>
                        </details>
                    </li>
                    <li>
                        <details>
                             <summary>PART 2: For bad_mux</summary>
                            <p>Step 1</p>
                            <pre>
<img width="604" alt="image" src="https://github.com/user-attachments/assets/b690e2b6-0071-4b63-a0ac-34c5d611c270">

Load bad_mux.v & its testbench to Iverilog.

<img width="604" alt="image" src="https://github.com/user-attachments/assets/6746e369-8755-4ea7-aa05-7d4ece8331d0">
                            </pre>
                            <p>Step 2</p>
                            <pre>
Execute a.out file.
                             
<img width="575" alt="image" src="https://github.com/user-attachments/assets/b5122755-55f4-44fd-ab41-ccc4f53e34a8">
                            </pre>
                            <p>Step 3</p>
                            <pre>
Load the .vcd file genrated into GTKWave.
                             
<img width="603" alt="image" src="https://github.com/user-attachments/assets/5036e31a-c1d3-4a69-aa7b-ea1e41484537">

No Activity on sel: When sel is low, i0 should be selected, but you are seeing no change in behavior. This indicates that the always block is not responding to changes in i0 or i1 when sel changes.

Multiplexer Acting Like a Flip-Flop: The behavior where only y is changing and not responding to i1 or sel signals properly is more like a flip-flop than a multiplexer. This is because the always @ (sel) sensitivity list limits the updates to y only when sel changes, which is incorrect for a combinational circuit like a multiplexer.

Why This is Happening:
The sensitivity list in your always @ (sel) block only watches for changes in sel. This means it ignores changes in i0 and i1, which explains why the multiplexer is not responding to changes in these inputs.

The non-blocking assignment (<=) is more suited for sequential logic (like flip-flops), not combinational logic. Non-blocking assignments introduce a delay, making the output update asynchronously, which is not ideal for this multiplexer.

The bad_mux's behavior is analyzed on GTKWave      

<img width="603" alt="image" src="https://github.com/user-attachments/assets/7cbe4b3d-550b-4582-b36d-2622a7c3675e">
                            </pre>
                            <p>Step 4</p>
                            <pre>
Invoke Yosys by using command yosys
                             
<img width="535" alt="image" src="https://github.com/user-attachments/assets/93b7987e-9035-4367-98ab-c50991173165">
                            </pre>
                            <p>Step 5</p>
                            <pre>
Read the library using read_liberty
                             
<img width="407" alt="image" src="https://github.com/user-attachments/assets/350ab2fc-7220-475f-af74-f140f2ca4d1a">
                            </pre>
                            <p>Step 6</p>
                            <pre>
Read the bad_mux.v using read_verilog
                             
<img width="382" alt="image" src="https://github.com/user-attachments/assets/614c51ae-abd8-4499-b73a-0f2afaa4634c">
                            </pre>
                            <p>Step 7</p>
                            <pre>
Define the module that needs to be synthesized
                             
<img width="323" alt="image" src="https://github.com/user-attachments/assets/1d57e190-29a1-4e5c-9f85-6095087ad5fd">
                            </pre>
                            <p>Step 8</p>
                            <pre>
Generate the netlist using abc command
                             
<img width="305" alt="image" src="https://github.com/user-attachments/assets/fa14ee56-311c-4fac-b19a-fd755fd19950">
                            </pre>
                            <p>Step 9</p>
                            <pre>
Write the netlist to bad_mux_net.v
                             
<img width="233" alt="image" src="https://github.com/user-attachments/assets/8f28c19c-70dc-429d-95eb-d5958b112e5a">
                            </pre>
                            <p>Step 10</p>
                            <pre>
Execute show to view the design
                             
<img width="474" alt="image" src="https://github.com/user-attachments/assets/52fbd2bc-40d5-49d1-b635-1c67696d1dac">
                            </pre>
                            <p>Step 11</p>
                            <pre>
Exit yosys and load the bad_mux_net.v to iverilog.
                             
<img width="605" alt="image" src="https://github.com/user-attachments/assets/bcaeb1ec-5167-45dd-b335-5301c7c367b8">
                            </pre>
                            <p>Step 12</p>
                            <pre>
Execute a.out file.
                             
<img width="537" alt="image" src="https://github.com/user-attachments/assets/25263fed-740f-4cf1-914e-0b3197b6832f">
                            </pre>
                            <p>Step 13</p>
                            <pre>
Load the generated .vcd file into GTKWave
                             
<img width="586" alt="image" src="https://github.com/user-attachments/assets/f8a5b674-6d98-4fb2-b173-affd170d910a">
                            <p>Step 14</p>
                            <pre>
Observe the behavior of GLS of ternary_operator_mux due to Simulation Mismatch
                             
<img width="632" alt="image" src="https://github.com/user-attachments/assets/fb763ad8-660c-4080-bff0-d3237cbcc8cc">
                            </pre>          
                        </details>
                    </li>
                </ul>
            </details>
        </li>
        <li>
        <details>
                <summary>Synthesis Simulation Mismatch</summary>
                <p>Step 1</p>
                <pre>
Load blocking_caveat.v & its testbench to Iverilog.
<img width="1232" alt="Screenshot 2024-05-26 at 3 20 01 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/98e89aec-e1e0-4371-9865-7f4d46970466">
                </pre>
                <p>Step 2</p>
                <pre>
Execute a.out file.
<img width="831" alt="Screenshot 2024-05-26 at 3 20 12 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/cabfbd67-5caf-467e-a4fe-36b9dd3613ae">
                </pre>
                <p>Step 3</p>
                <pre>
Load the .vcd file genrated into GTKWave.
<img width="1056" alt="Screenshot 2024-05-26 at 3 20 37 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/cd3b4d01-c92d-40e8-842f-e41fcb512967">
The blocking_caveat's behavior is analyzed on GTKWave                            
<img width="1362" alt="Screenshot 2024-05-26 at 3 21 17 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/0313fa9c-df40-46d2-9e31-0e18b9eb5b84">
                </pre>
                <p>Step 4</p>
                <pre>
Invoke Yosys by using command yosys
<img width="809" alt="Screenshot 2024-05-26 at 3 21 29 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/45aa14d6-5cc0-4a4d-b629-74bc87fda4fa">
                </pre>
                <p>Step 5</p>
                <pre>
Read the library using read_liberty
<img width="727" alt="Screenshot 2024-05-26 at 3 21 43 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/e4aa45a5-c575-4ecc-9fe6-e10553ba31da">
                </pre>
                <p>Step 6</p>
                <pre>
Read the blocking_caveat.v using read_verilog
<img width="709" alt="Screenshot 2024-05-26 at 3 21 55 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/2c84de8b-63bc-4394-b833-79569ab86d0c">
                </pre>
                <p>Step 7</p>
                <pre>
Define the module that needs to be synthesized
<img width="596" alt="Screenshot 2024-05-26 at 3 23 34 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/886c9129-5cf7-4622-8857-326ffef0597f">
                </pre>
                <p>Step 8</p>
                <pre>
Generate the netlist using abc command
<img width="615" alt="Screenshot 2024-05-26 at 3 24 14 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/3035c361-2a06-41ca-8363-5a40d4827d87">
                </pre>
                <p>Step 9</p>
                <pre>
Write the netlist to blocking_caveat_net.v
<img width="523" alt="Screenshot 2024-05-26 at 3 25 02 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/cef23d28-8d32-4c0c-941f-a0420db792d6">
                </pre>
                <p>Step 10</p>
                <pre>
Execute show to view the design
<img width="603" alt="Screenshot 2024-05-26 at 3 25 14 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/f05de1e7-98ce-4ac3-bbaa-fbf14a31336c">
                </pre>
                <p>Step 11</p>
                <pre>
Exit yosys and load the blocking_caveat_net.v to iverilog.
<img width="1370" alt="Screenshot 2024-05-26 at 3 27 05 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/db39196e-3fba-424f-95ad-6b2f2e069d03">
                </pre>
                <p>Step 12</p>
                <pre>
Execute a.out file.
<img width="832" alt="Screenshot 2024-05-26 at 3 27 14 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/897f10b8-5491-46d7-a7ff-ca0eac28123a">
                </pre>
                <p>Step 13</p>
                <pre>
Load the generated .vcd file into GTKWave
<img width="1059" alt="Screenshot 2024-05-26 at 3 27 38 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/2f6188c0-d262-48f1-a756-24f1c709de6f">
                </pre>
                <p>Step 14</p>
                <pre>
Observe the behavior of GLS of blocking_caveat due to Simulation Mismatch
<img width="1357" alt="Screenshot 2024-05-26 at 3 28 12 PM" src="https://github.com/c-dhanush-p/SFAL-VSD/assets/170220133/4f2dcd1c-5d73-474e-bf68-12c82ff30205">
                </pre>
            </details>
        </li>
    </ul>
</details>































































